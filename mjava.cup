import java.io.File;
import java.io.FileOutputStream;
import rs.etf.pp1.mj.runtime.*;
import java.util.stream.Collectors;
import java.util.*;
import java_cup.runtime.*;
import rs.etf.pp1.symboltable.structure.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.*;

init with {:
  Tab.init();
  boolType = new Struct(Struct.Bool);
  boolObj = new Obj(Obj.Type, "bool", boolType);
  Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool", boolType));
:}

action code {:
    Struct varTypeHelper;
    Obj methodObjHelper;
    Stack<Integer> rArgCounters = new Stack<Integer>();
    Stack<Obj> methodCalls = new Stack<Obj>();
    Obj methodObj;
    Obj classObj;
    Struct extendsType;
    Struct classT;
    int argCount = 0;
    int rArgCount = 0;
    int globalVar = 0;
    int localVar = 0;
    int globalConst = 0;
    int globalArrays = 0;
    int classDef = 0;
    int classMethodDef = 0;
    int statementBlock = 0;
    int mainFuncCalls = 0;
    int formalArguments = 0;
    int classFields;

    boolean isArray;
    int arrays = 0, vars = 0, consts = 0, methods = 0;;
    boolean insideClass = false;
    boolean insideMethod = false;
    boolean global = true;
    boolean insideMain = false;
    boolean hasReturn = false;
    int forLoopLevel = 0;

private void incrementArgs() {
  int x = rArgCounters.pop();
  x++;
  rArgCounters.push(x);
}

private int getOperand(String s) {
  switch(s) {
    case "+": return Code.add;
    case "-": return Code.sub;
    case "*": return Code.mul;
    case "/": return Code.div;
    case "%": return Code.rem;
    case "++": return Code.add;
    case "--": return Code.sub;
  }

  return -1;
}

private boolean opType(String s) {
  switch(s) {
    case "+": case "-": case "/": case "*": case "%":
      return false;
    case "*=": case "/=": case "%=": case "+=": case "-=":
      return true;
  }

  return false;
}
private boolean checkStatic(Obj o) {
  if(o != null && o.getKind() == Obj.Meth) {
    if(methodObj != o)
      return o.getLocalSymbols().stream().filter(x-> x.getName() == "this").count() == 0;
    else
       return Tab.currentScope().findSymbol("this") == null;
  }

  return false;
}
//TODO: finish this
private boolean validInheritance(Obj method) {
  if(!insideClass)
    return true;

  Obj extendedMethod = searchClass(extendsType, method.getName());

  if(extendedMethod.getType() == Tab.noType) {
    return true;
  } else {
    return false;
  }


}

private Obj findObj(Obj obj, String name) {
  //if we are in method and method is static we search for obj differently

  if(obj != null && obj.getType().getKind() == Struct.Class) {
     if(insideClass &&
        obj.getType().getElemType() == classObj.getType()) { //if var.method and we are inside class
       print("SHOULD BE HERE BUT AM NOT " + name);
       return Tab.find(name);
     } else if (obj.getKind() == Obj.Type) { //if Class.Method
       Obj result;
       if(insideClass && obj  == classObj) {
         result = Tab.find(name);
       } else {
         result = obj.getType().getMembersTable().searchKey(name);
       }

       return checkStatic(result) ? result : Tab.noObj;
     }
     else {
       print("SHOULD'nt BE HERE BUT I AM NOT " + name);
       SymbolDataStructure table = obj.getType().getElemType().getMembersTable();
       Obj result = table.searchKey(name);

       return result == null ? Tab.noObj : result;
     }
  }

  return Tab.noObj;
}

private Struct getArgument(int fpos) {
  print("FPOS: " + fpos + " " +  methodCalls.peek().getName() + " " +methodCalls.peek().getLevel());

  return methodCalls.peek().getLocalSymbols().stream().filter(o -> o.getFpPos() == fpos).collect(Collectors.toList()).get(0).getType();
}

private Obj searchClass(Struct cl, String name) {
  Obj result = cl.getMembersTable().searchKey(name);
  return result == null ? Tab.noObj : result;
}

private Obj insertSymbol(int kind, String name, Struct type) {
  int numSym = Tab.currentScope().values().size();

  if(kind != Obj.Type && type.getKind() == Struct.Class) {
    Struct tmp = new Struct(Struct.Class);
    tmp.setElementType(type);
    type = tmp;
  }

  Obj result = Tab.insert(kind, name, type);
  int numSymAfter = Tab.currentScope().values().size();

  if(numSym != numSymAfter) {
    print("Definisan simbol: " + name);
  }
  else {
    parser.report_error("Redefinisan simbol: " + name + " u tabeli simbola", null);
  }

  return result;
}

private void print(String s) { System.out.println(s); System.out.flush(); }

public void printResult() {
            print("Pronadjeno: " + globalVar + " globalnih promenljivih");
            print("Pronadjeno: " + globalConst + " globalnih konstanti");
            print("Pronadjeno: " + globalArrays + " globalnih nizova");
            print("Pronadjeno: " + localVar + " lokalnih promenljivih");
            print("Pronadjeno: " + classDef + " definicija klasa");
            print("Pronadjeno: " + classMethodDef + " metoda");
            print("Pronadjeno: " + statementBlock + " statement blokova");
            print("Pronadjeno: " + mainFuncCalls + " poziva funkcija u mainu");
            print("Pronadjeno: " + formalArguments + " formalnih argumenata");
            print("Pronadjeno: " + classFields + " polja klasa");
}

:}


parser code {:
    Struct boolType;
    Obj boolObj;
    boolean _main = true;
    int depth = 0;
    boolean errorDetected = false;
    public int error_sync_size() { return 1; }
    public static void main(String args[]) throws Exception {
        java.io.FileReader r = new java.io.FileReader(args[0]);
        Lexer skener = new Lexer(r);
        parser p = new parser(skener);
        Symbol s = p.parse();  //pocetak parsiranja

        if(!p.errorDetected) {
          File objFile = new File("test/program.obj");
          if(objFile.exists())
            objFile.delete();
          Code.write(new FileOutputStream(objFile));
          System.out.println("************************USPESNO ZAVRSENO PARSIRANJE!*************************");
        }
    }

    /***********************************************************************
    * slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
    ***********************************************************************/
    public void report_fatal_error(String message, Object   info) throws java.lang.Exception {
      done_parsing();
//      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

  public void report_error(String message, Object info)
    {
      errorDetected = true;
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
          System.err.println(" na liniji " + (((Symbol)info).right + 1) + " gresna na: " + ((Symbol)info).value.toString());
      else System.err.println("");
    }

:}



terminal IDENT, NUMCONST,BOOLCONST, CHARCONST;

terminal MULOPLEFT, MULOPRIGHT, MINUS, PLUS, ADDOPRIGHT;
terminal RELOP, ASSIGN, SCOLIN, DOT;
terminal DPLUS, DMINUS, AND, OR, COLIN;
terminal LBR, RBR, LSBR, RSBR, LCBR, RCBR;

terminal CONST, CLASS, EXTENDS, STATIC, VOID, IF, ELSE, FOR, BREAK;
terminal CONTINUE, RETURN, PRINT, READ, PROGRAM, NEW;

non terminal Program, ProgName, Declarations, DeclRepeat, ConstDecl, ConstDef, ConstDefRepeat;
non terminal VarDeclGlobal, VarOpt, VarOptGlobalRepeat,VarDeclLocalWithError, VarDeclClassRepeatOpt, Extends;
non terminal VarDeclLocal, VarDeclClassRepeat, VarOptLocalRepeat, VarDeclLocalRepeat;
non terminal MethodImplOpt, MethodDecl, MethodDeclRepeat, FormParsWithError, Parameter, ParameterColinError, ParameterRbrError, ParameterRepeat;
non terminal Statement, StatementRepeat, ElsStmt, DesignatorStatement, DesignatorStatementErr;
non terminal DesignatorStmtOptions, DesignatorStatementOpt, ActPars, ActParsHelper, ActualParameter, ActParamRepeat;
non terminal ConditionWithError, ConditionOpt, CondTerm, CondTermOr, CondTermRep, CondFact, CondFactAnd, CondFactRepeat;
non terminal RelopExp, MinusOpt, ExprOrError, OptParameters;
non terminal NewParameters, DesignatorParam, DesignatorParamRep;
non terminal Assignop, AddopLeft, Condition, VarDeclLocalScolinError, VarDeclLocalLcbrError, VarDeclLocalRepeatOpt;
non terminal StartVarOpt, EndVarOpt, ActParsWithError, Addop, Mulop;

non terminal java.lang.Integer ConstOpt;
non terminal Struct Type, ExtType, ClassType, ClassDecl;
non terminal Boolean SbrOpt, StaticOpt;
non terminal Obj ClassVar, Designator, Constant;
non terminal Obj Expr, Factor, Term, AssignWithError, ExprOpt;

precedence left ELSE;
//Think about chaining local symbols to program!
Program ::= PROGRAM {: Tab.openScope();global = true; :}
            ProgName DeclRepeat LCBR {: global = false; :}
            MethodDeclRepeat RCBR
            {:
              Tab.dump();
              Code.dataSize = Tab.currentScope().getnVars();
              Tab.closeScope();
              printResult();
            :};
ProgName ::= IDENT:progName
             {:
                insertSymbol(Obj.Prog, progName.toString(), Tab.noType);
             :};

Declarations ::= ConstDecl | VarDeclGlobal | ClassDecl;
DeclRepeat ::= /* epsilon */
              |
               Declarations DeclRepeat;

Constant ::= NUMCONST:match
             {:
               RESULT = new Obj(Obj.Con, "", Tab.intType);
               RESULT.setAdr(Integer.parseInt(match.toString()));
             :}
           | BOOLCONST:match
             {:
               RESULT = new Obj(Obj.Con, "", parser.boolType);
               RESULT.setAdr(match == "true" ? 1 : 0);
             :}
           |
             CHARCONST:match
             {:
               RESULT = new Obj(Obj.Con, "", Tab.charType);
               print("HEJ NASAO SAM " + match.toString().charAt(1));
               RESULT.setAdr(match.toString().charAt(1));
             :};
ConstDecl ::= CONST Type:type {: varTypeHelper = type; :}
              ConstDefRepeat SCOLIN {: print("ConstDecl state found"); :};
ConstDef  ::=  IDENT:varName
               {:
                 varTypeHelper = varTypeHelper;
                 insertSymbol(Obj.Con, varName.toString(), varTypeHelper);
               :}
               ASSIGN Constant:cn
               {:
                  if(cn.getType().getKind() != varTypeHelper.getKind()) {
                     parser.report_error("Tip konstante i konstanta se ne poklapaju!", null);
                  }
               :};
ConstDefRepeat ::= ConstDef {: if(global) globalConst++; :}
                  |
                   ConstDef COLIN ConstDefRepeat {: if(global) globalConst++; :} ;

//Proveri sta radis ovde mozda ne moze ovako
VarDeclGlobal ::= Type:varType {: varTypeHelper = varType; :}
                  VarOptGlobalRepeat
                  {: if(global && !insideClass && !insideMain) {
                    if(isArray)
                      globalArrays++;
                    else
                      globalVar++;
                    } else if(insideClass && !insideMethod) {
                      classFields++;
                    }
                      print("Global var found!");
                  :};
VarOpt  ::= IDENT:varName SbrOpt:array
            {:
               Obj o = insertSymbol(insideClass && !insideMethod ? Obj.Fld : Obj.Var, varName.toString(), array ? new Struct(Struct.Array, varTypeHelper) : varTypeHelper);
               print("UBACIO SIMBOL: " + o.getName() + " levela: " + o.getLevel());
            :};

StartVarOpt ::= VarOpt COLIN  |
                error COLIN {:print("StartVar error"); :};
EndVarOpt ::= VarOpt SCOLIN |
              error SCOLIN {:print("EndVar error"); :};

VarOptGlobalRepeat ::= StartVarOpt VarOptGlobalRepeat {: if(!insideClass && !insideMain) {
                                                           if(isArray)
                                                             globalArrays++;
                                                           else
                                                                       globalVar++;
                                                                  } else if(insideClass && !insideMethod) {
                                                                       classFields++;
                                                                  }
                                                      :}
                      | EndVarOpt;

VarDeclLocal ::= Type:varType {: varTypeHelper = varType; :}
                 VarOptLocalRepeat {:
                                     print("Local var found!");
                                   :};
VarOptLocalRepeat ::= VarOpt
                     {: if(insideMain) {
                          localVar++;
                        }
                     :}
                      COLIN  VarOptLocalRepeat
                    |
                      VarOpt
                     {: if(insideMain) {
                          localVar++;
                        }
                     :};
VarDeclLocalScolinError ::= VarDeclLocal SCOLIN
                          |
                            error SCOLIN;
VarDeclLocalLcbrError ::= VarDeclLocal SCOLIN LCBR
                        |
                          error LCBR;
VarDeclLocalRepeat ::= VarDeclLocalScolinError VarDeclLocalRepeat
                     |
                       VarDeclLocalLcbrError;
//TODO: Error can have wrong terminal for example "}"
VarDeclLocalWithError ::= VarDeclLocal
                        | error;
VarDeclClassRepeat ::= VarDeclLocalWithError SCOLIN
                     | VarDeclLocalWithError SCOLIN VarDeclClassRepeat;
VarDeclClassRepeatOpt ::= |
                          VarDeclClassRepeat;
VarDeclLocalRepeatOpt ::= LCBR
                        | VarDeclLocalRepeat;
SbrOpt  ::=  {: RESULT = isArray = false; :}
          |  LSBR RSBR {: RESULT = isArray = true; :};
//TODO: VarDeclLocal should go up to LCBR but not sure LCBR will be there!
ClassDecl ::= ClassType:cT ClassVar Extends LCBR VarDeclClassRepeatOpt MethodImplOpt RCBR
              {:
                Tab.chainLocalSymbols(cT);
                Tab.closeScope();
                print("ClassDecl state found!"); insideClass = false;
              :}; //TODO: rethink
ClassType ::= CLASS:classType
              {:
                 RESULT = new Struct(Struct.Class);
                 classT = RESULT;
                 insideClass = true;
                 classDef++;
                 print("Found class!");
              :};
ClassVar ::= IDENT:className
             {:
                RESULT = insertSymbol(Obj.Type, className.toString(), classT);
                classObj = RESULT;
                Tab.openScope();
             :};
Extends ::= /* epsilon */
          |
            EXTENDS Type:type
            {:
              if(type.getKind() != Struct.Class) {
                parser.report_error("Klasa mora nasledjivati drugu klasu!", null);
                extendsType = Tab.noType;
              } else {
                 if(type == classT) {
                   parser.report_error("Klasa ne moze nasledjivati samu sebe!", null);
                   extendsType = Tab.noType;
                 } else {
                   extendsType = type;
                 }
              }


            :}
           |
            error;
MethodImplOpt ::= |
                  LCBR MethodDeclRepeat RCBR;
StaticOpt ::= /* epsilon */ {: RESULT = false; :}
             |
              STATIC
              {:
                 if(!insideClass) {
                   parser.report_error("Kljucna rec static se moze koristiti samo uokviru klase!", null);
                 }

                 RESULT = true;
              :};
MethodDecl ::=  StaticOpt:isStatic ExtType:retType IDENT:name
                {:
                   if(isStatic && !insideClass) {
                     parser.report_error("Globalne metode ne mogu biti staticke!", null);
                   }

                   if(name.toString().equals("main")) {
                     insideMain = true;
                     Code.mainPc = Code.pc;
                   }

                   if(insideClass)
                     classMethodDef++;

                   insideMethod = true;
                   print(name.toString());

                   methodObj = insertSymbol(Obj.Meth, name.toString(), retType);

                   argCount = 0;
                   Tab.openScope();

                   if(!isStatic && insideClass) {
                     Obj obj = insertSymbol(Obj.Var, "this", classT);
                     obj.setFpPos(argCount);
                     argCount++;
                   }
                :}
                FormParsWithError {: methodObj.setLevel(argCount); :}
                VarDeclLocalRepeatOpt StatementRepeat RCBR
                {:
                   if(insideMain) {
                     insideMain = false;
                   }
                   if(retType != Tab.noType && !hasReturn) {
                      parser.report_error("Nedostaje return statement u metodi!", null);
                   }

                   print("MethodDecl found!");
                   hasReturn = false;
                   insideMethod = false;
                   Tab.chainLocalSymbols(methodObj);
                   Tab.closeScope();
                :};

MethodDeclRepeat ::= /* epsilon */
                   |
                     MethodDecl MethodDeclRepeat;
FormParsWithError ::= LBR  RBR
                    | LBR ParameterRepeat;
Parameter ::= Type:type IDENT:varName SbrOpt:array
              {:
                Obj obj = insertSymbol(Obj.Var, varName.toString(), array ? new Struct(Struct.Array, type) : type);
                obj.setFpPos(argCount);
                argCount++;
              :};
ParameterColinError ::= Parameter COLIN
                      |
                        error COLIN;
ParameterRbrError ::= Parameter RBR
                    |
                      error RBR;
ParameterRepeat ::= ParameterRbrError
                    | ParameterColinError ParameterRepeat;

Type ::= IDENT:typeName
{:
    Obj typeNode = Tab.find(typeName.toString());
   	if (typeNode == Tab.noObj) {
   		parser.report_error("Nije pronadjen tip " + typeName + " u tabeli simbola", null);
   		RESULT = Tab.noType;
   	}
   	else {
   		if (Obj.Type == typeNode.getKind()) {
   			RESULT = typeNode.getType();
   		}
   		else {
   			parser.report_error("Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ", null);
   			RESULT = Tab.noType;
   		}
   	}
:};

ExtType ::= Type:type {: RESULT = type; :}
           |
            VOID {: RESULT = Tab.noType; :};

Statement ::= DesignatorStatement SCOLIN {: print("Statement.DS state found"); :}
            |
              IF LBR ConditionWithError RBR Statement ElsStmt {: print("Statement.IFELSE state found"); :}
            |
              FOR {: forLoopLevel++; :} LBR DesignatorStatementOpt SCOLIN ConditionOpt SCOLIN DesignatorStatementOpt RBR Statement SCOLIN {: forLoopLevel--; :} //not sure if SCOLIN needed here
            |
              BREAK SCOLIN
              {:
                if(forLoopLevel == 0)
                  parser.report_error("break can't be used outside for loop!", null);
                print("Statement.BREAK state found");
              :}
            |
              CONTINUE SCOLIN
              {:
                if(forLoopLevel == 0)
                  parser.report_error("continue can't be used outside for loop!", null);
                print("Statement.BREAK state found");
              :}
            |
              RETURN ExprOpt:e SCOLIN
              {:
                Code.put(Code.return_);
                hasReturn = true; print("Statement.RETURN state found");

                if(!insideMethod) {
                  parser.report_error("Naredba return se sme koristiti samo uokviru funckije/metode", null);
                } else {
                  if(methodObj.getType() != e.getType()) {
                    parser.report_error("Povratni tip metode i naredbe return se ne poklapaju", null);
                  }
                }

              :}
            |
              READ LBR Designator:des RBR SCOLIN
              {:

                 if(des.getKind() != Obj.Var &&
                    des.getKind() != Obj.Fld &&
                    des.getKind() != Obj.Elem) {
                   parser.report_error("Ne moze se pozvati READ za ovaj simbola!", null);
                 }

                 if(des.getType() != Tab.intType &&
                    des.getType() != Tab.charType &&
                    des.getType().getKind() != Struct.Bool) {
                   parser.report_error("Ne moze se pozvati READ za ovaj tip simbola!", null);
                 }

                if(des.getType() == Tab.intType) {
                  Code.put(Code.read);
                } else {
                  Code.put(Code.bread);
                }

                Code.store(des);
                print("READ"); if(insideMain) mainFuncCalls++;
              :}
            |
              PRINT LBR Expr:e ConstOpt:c RBR SCOLIN
              {:
                if(e.getType() != Tab.intType &&
                   e.getType() != Tab.charType &&
                   e.getType().getKind() != Struct.Bool) {
                   parser.report_error("Ne moze se pozvati PRINT za ovaj tip simbola!", null);
                 }

                if(insideMain) mainFuncCalls++;

                if(e.getType() == Tab.intType) {
                  Code.loadConst(c == null ? 5 : c);
                  Code.put(Code.print);
                } else if (e.getType() == Tab.charType) {
                  Code.loadConst(c == null ? 1 : c);
                  Code.put(Code.bprint);
                }
              :}
            |
              LCBR StatementRepeat RCBR {: print("StatementRepeat state found"); statementBlock++; :};
StatementRepeat ::= |
                    Statement StatementRepeat;
ElsStmt ::= |
            ELSE Statement;
ConstOpt ::= /* epsilon */ {: RESULT = null; :}
           |
             COLIN NUMCONST:n {: RESULT = java.lang.Integer.parseInt(n.toString()); :};


DesignatorStatement ::= Designator:des AssignWithError:res
                        {:
                          if(des.getKind() != Obj.Var &&
                             des.getKind() != Obj.Fld &&
                             des.getKind() != Obj.Elem) {
                               parser.report_error("Ne moze se dodeliti vrednost ovom simbolu!", null);
                          }


                          print("TIP REZULTATA " + des.getName() + " " + res.getType() + " " + des.getType() + " " + des.getType().compatibleWith(res.getType()));

                          if(des != Tab.noObj && !des.getType().compatibleWith(res.getType())) {
                            parser.report_error("Izraz je pogresnog tipa!", null);
                          }

                          Code.store(des);
                        :}
                      |
                        Designator:des
                        {:
                          if(des.getKind() != Obj.Meth) {
                            parser.report_error("Simbol nije metoda!", null);
                            methodObjHelper = new Obj(Obj.Meth, "error", Tab.noType);
                          } else {
                            methodObjHelper = des;
                          }

                          rArgCount = checkStatic(methodObjHelper) ? 0 : 1;
                          rArgCounters.push(rArgCount);
                          print("PUSHING " + methodObjHelper.getName());
                          methodCalls.push(methodObjHelper);
                        :}
                        LBR ActParsWithError RBR
                        {:
                          rArgCounters.pop();
                          print("POPING " + methodCalls.peek().getName()); methodCalls.pop();
                        :}
                      |
                        Designator:des DesignatorStmtOptions:op
                        {:
                          if(des.getKind() != Obj.Var &&
                             des.getKind() != Obj.Fld &&
                             des.getKind() != Obj.Elem) {
                            parser.report_error("Ne moze se izvesti operacija nad ovim simbolom!", null);
                          }

                          if(des.getType() != Tab.intType) {
                            parser.report_error("Operacija se moze izvesti samo na tipu: int!", null);
                          }

                          Code.load(des);
                          Code.loadConst(1);
                          Code.put(getOperand(op.toString()));
                          Code.store(des);
                        :};
AssignWithError ::= Assignop Expr:expr {: RESULT = expr; print("AssignOp Expr"); :};

//Think about this!
DesignatorStmtOptions ::=  DPLUS:d {: RESULT = d; :} | DMINUS:d {: RESULT = d; :};
DesignatorStatementOpt ::= |
                           DesignatorStatementErr;
DesignatorStatementErr ::= DesignatorStatement
                         | error {: print("MATCHED!") ;:};
ActParsHelper ::= Expr:e
                  {:
                    methodObjHelper = methodCalls.peek();

                    if(methodObjHelper.getName() != "error" &&
                       methodObjHelper.getLevel() > rArgCounters.peek() &&
                       e.getType() != getArgument(rArgCounters.peek())) {
                      parser.report_error("Pogresan tip " + (rArgCounters.peek() + 1) + ". argumenta!", null);
                    }

                    incrementArgs();
                  :}
                |
                  ActParsHelper COLIN Expr:e
                  {:
                    methodObjHelper = methodCalls.peek();

                    if(methodObjHelper.getName() != "error" &&
                       methodObjHelper.getLevel() > rArgCounters.peek() &&
                       e.getType() != getArgument(rArgCounters.peek())) {
                      parser.report_error("Pogresan tip " + (rArgCounters.peek() + 1) + ". argumenta!", null);
                    }

                    incrementArgs();

                    print("ActPars state found");
                  :};
ActParsWithError ::= ActPars
                     {:
                        methodObjHelper = methodCalls.peek();

                        if(methodObjHelper.getName() != "error") {
                          if(rArgCounters.peek() != methodObjHelper.getLevel()) {

                            parser.report_error("Pogresan broj argumenata! " + rArgCounters.peek() + " " + methodObjHelper.getLevel() + methodObjHelper.getName(), null);
                          }
                        }
                     :}
                   |
                     error;
ActPars ::= /* epsilon */
          |
            ActParsHelper;
ActualParameter ::= COLIN Expr;
ActParamRepeat ::= |
                  ActualParameter ActParamRepeat;
Condition ::= CondTerm CondTermRep {: print("Condition state found"); :};

ConditionOpt ::= |
                 ConditionWithError;
ConditionWithError ::= Condition
                 | error {: print("ConditionWithError error matched!"); :};
CondTerm ::= CondFact CondFactRepeat {: print("CondFact state found"); :};
CondTermOr ::= OR CondTerm;
CondTermRep ::= |
                CondTermOr CondTermRep;

CondFact ::= Expr RelopExp {: print("CondFact state found"); :};
CondFactAnd ::= AND CondFact;
CondFactRepeat ::= |
                   CondFactAnd CondFactRepeat;
RelopExp ::= |
             RELOP Expr;

MinusOpt ::= /* epsilon */
           |
             MINUS {: Code.put(Code.neg); :};
Expr ::= MinusOpt Term:t
         {:
           RESULT = t;
         :}
       |
         Expr:e Addop:op Term:t
        {:
          if(e.getType() != Tab.intType || t.getType() != Tab.intType) {
            parser.report_error("Terms must be of type int!", null);
          }

          if(!e.getType().compatibleWith(t.getType())) {
            parser.report_error("Nekopatibilni tipovi!", null);
          }

         boolean b = opType(op.toString());
         print("OPERAND JE: " + op.toString());
         int operand = getOperand("" + op.toString().charAt(0));

         if(b) {
            if(e.getKind() != Obj.Var &&
               e.getKind() != Obj.Fld &&
               e.getKind() != Obj.Elem) {
              parser.report_error("Ovaj simbol ne moze ici sa ovim operandom!", null);
            } else {
              Code.load(e);
              Code.put(operand);
              Code.store(e);
              Code.load(e);
            }
          } else {
            Code.put(operand);
          }

          RESULT = new Obj(Obj.Var, "", e.getType());;
          print("Expr state found");
        :};
ExprOpt ::= /* epsilon */ {: RESULT = Tab.noObj; :}
          |
            Expr:e {: RESULT = e; :};
ExprOrError ::= Expr | error;

Term ::= Factor:factor {: RESULT = factor; :}
       |
         Term:t Mulop:op Factor:f
         {:
           if(t.getType() != Tab.intType || f.getType() != Tab.intType) {
             parser.report_error("Los tip!", null);
           }

           boolean b = opType(op.toString());
           int operand = getOperand("" + op.toString().charAt(0));

           if(b) {
              if(t.getKind() != Obj.Var &&
                 t.getKind() != Obj.Fld &&
                 t.getKind() != Obj.Elem) {
                parser.report_error("Ovaj simbol ne moze ici sa ovim operandom!", null);
               } else {
                 Code.put(operand);
                 Code.store(t);
                 //TODO: rethink this
                 Code.load(t);
               }
            } else {
              Code.put(operand);
            }

           RESULT = new Obj(Obj.Var, "", t.getType());
           print("Term state found");
         :};

Factor ::= Designator:des
           {:
             methodCalls.push(des);
             int argCnt = (checkStatic(methodCalls.peek()) ? 0 : 1);
             rArgCounters.push(argCnt);
             if(des.getKind() != Obj.Meth) {
               print("TIP: " + des.getKind());
               Code.load(des);

             } else {
                //TODO: finish this for method calls
             }
           :}
           OptParameters
           {:                          rArgCounters.pop();
             methodCalls.pop();
             RESULT = des;
             print("Factor.MethodCall state found " + des.getName());
           :}
         |
           Constant:c {: Code.load(c); RESULT = c; print("Factor.CONST state found"); :}
         |
           NEW Type:type NewParameters:nparam
           {:
             //TODO noidea!
             if(nparam != Tab.intType && nparam != Tab.noType) {
               parser.report_error("Parametri operanda new moraju biti tipa int!", null);
             }

             if(nparam == Tab.noType && type.getKind() != Struct.Class) {
               parser.report_error("Simbol nije klasnog tipa", null);
             }
             RESULT = new Obj(Obj.Var, "", type);;
             print("Factor.new state found");
           :}
         |
           LBR Expr:e RBR {: RESULT = e; print("Factor.BREXPR state found"); :}
         |
           Designator LBR Expr;
OptParameters ::= /* epsilon */
                |
                  LBR ActParsWithError RBR  {: if(insideMain) mainFuncCalls++; :};
NewParameters ::= /* epsilon */ {: RESULT = Tab.noType; :}
                |
                  LSBR Expr:e RSBR {: RESULT = e; :};

Designator ::= Designator:des DOT IDENT:ident
               {:
                  if(des.getType().getKind() != Struct.Class) {
                    if(des != Tab.noObj)
                      parser.report_error("Promenljiva" + des.getName() +  " nije klasnog tipa!", null);
                    RESULT = Tab.noObj;
                  } else {
                    RESULT = findObj(des, ident.toString());
                    if(RESULT == Tab.noObj) {
                      parser.report_error("Nepostojece polje/metoda " + ident.toString() +  " za varijablu " + des.getName(), null);
                    }

                    if(des.getType().getKind() != Obj.Type)
                      Code.load(des);
                  }
               :}
             |
               Designator:des LSBR
               {:
                  if(des.getType().getKind() != Struct.Array) {
                    parser.report_error("Promenljiva" + des.getName() +  " nije tipa niz!", null);
                  } else {
                    Code.load(des);
                  }

                  RESULT = new Obj(Obj.Elem, "", des.getType().getElemType());
               :}
               ExprOrError RSBR
             |
               IDENT:ident
               {:
                 Obj des = Tab.find(ident.toString());

                 if(insideMethod && checkStatic(methodObj)) {//ifStatic
                   print("WHYYY?!" + des.getName() + " " + methodObj.getName());
                   if(des.getKind() == Obj.Fld) {
                     des = Tab.noObj;
                   } else if(des.getKind() == Obj.Meth && !checkStatic(des))  {
                     des = Tab.noObj;
                   }
                 }

                 if(des == Tab.noObj)
                   parser.report_error("Ne postoji simbol " + ident.toString() + " u tabeli simbola!", null);

                 RESULT = des;
               :};

//Designator ::= IDENT:i DesignatorParamRep {: print("Designator state found" + i); :};
DesignatorParam ::= DOT IDENT | LSBR ExprOrError RSBR;
DesignatorParamRep ::=
                       | DesignatorParam DesignatorParamRep;

Assignop ::= ASSIGN | ADDOPRIGHT | MULOPRIGHT {: print("Assignop state found"); :};
Addop ::= AddopLeft:al {: RESULT = al.toString(); :} | ADDOPRIGHT:ar {: RESULT = ar.toString(); print("Addop state found"); :};
AddopLeft ::= PLUS:p {: RESULT = p; :} | MINUS:m {: RESULT = m; :};
Mulop ::= MULOPLEFT:a {: RESULT = a.toString(); :}

RightOperands ::= ADDOPRIGHT:a {: RESULT = a.toString(); | MULOPRIGHT:b {: result = b.toString() :};
